<application>
  <component name="AppStorage">
    <histories>
      <item value="Describes a situation when a function returns normally with the specified return [value]. * * The possible values of [value] are limited to `true`, `false` or `null`. * * Use [SimpleEffect.implies] function to describe a conditional effect that happens in such case." />
      <item value="Describes a situation when a function returns normally with the specified return [value]." />
      <item value="Equivalent to calling * {@link android.view.View#setOnClickListener(android.view.View.OnClickListener)} * to launch the provided {@link PendingIntent}. The source bounds * ({@link Intent#getSourceBounds()}) of the intent will be set to the bounds of the clicked * view in screen space. * Note that any activity options associated with the mPendingIntent may get overridden * before starting the intent. * * When setting the on-click action of items within collections (eg. {@link ListView}, * {@link StackView} etc.), this method will not work. Instead, use {@link * RemoteViews#setPendingIntentTemplate(int, PendingIntent)} in conjunction with * {@link RemoteViews#setOnClickFillInIntent(int, Intent)}." />
      <item value="When using collections (eg. {@link ListView}, {@link StackView} etc.) in widgets, it is very * costly to set PendingIntents on the individual items, and is hence not permitted. Instead * a single PendingIntent template can be set on the collection, see {@link * RemoteViews#setPendingIntentTemplate(int, PendingIntent)}, and the individual on-click * action of a given item can be distinguished by setting a fillInIntent on that item. The * fillInIntent is then combined with the PendingIntent template in order to determine the final * intent which will be executed when the item is clicked. This works as follows: any fields * which are left blank in the PendingIntent template, but are provided by the fillInIntent * will be overwritten, and the resulting PendingIntent will be used. The rest * of the PendingIntent template will then be filled in with the associated fields that are * set in fillInIntent. See {@link Intent#fillIn(Intent, int)} for more details." />
      <item value="Flag indicating that if the described PendingIntent already exists, * then keep it but replace its extra data with what is in this new * Intent. For use with {@link #getActivity}, {@link #getBroadcast}, and * {@link #getService}. &lt;p&gt;This can be used if you are creating intents where only the * extras change, and don't care that any entities that received your * previous PendingIntent will be able to launch it with your new * extras even if they are not explicitly given to it." />
      <item value="minus" />
      <item value="equal" />
      <item value="Immersive Mode" />
      <item value="Evenly" />
      <item value="distribute" />
      <item value="显示" />
      <item value="Bundle in which to place your saved state." />
      <item value="State which will be saved across reboots." />
      <item value="Get the drawable used for the switch &quot;thumb&quot; - the piece that the user * can physically touch and drag along the track." />
      <item value="Get the drawable used for the track that the switch slides within" />
      <item value="A top-level container that represents a settings screen. This is the root component of your * {@link Preference} hierarchy. A {@link PreferenceFragmentCompat} points to an instance of this * class to show the preferences. To instantiate this class, use * {@link PreferenceManager#createPreferenceScreen(Context)}." />
      <item value="Common base class for preferences that have two selectable states, save a boolean value, and * may have dependent preferences that are enabled/disabled based on the * current state." />
      <item value="Modifies an ObservableSource to perform its emissions and notifications on a specified {@link Scheduler}, * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} &quot;island size&quot;." />
      <item value="Asynchronously subscribes Observers to this ObservableSource on the specified {@link Scheduler}." />
      <item value="quotient" />
      <item value="slow" />
      <item value="调色板" />
      <item value="色板" />
      <item value="请授予权限！" />
      <item value="使用蓝牙需要您允许通过该权限" />
      <item value="使用蓝牙需要，您允许通过该权限" />
      <item value="申请蓝牙权限" />
      <item value="Relative path of this media item within the storage device where it * is persisted. For example, an item stored at * {@code /storage/0000-0000/DCIM/Vacation/IMG1024.JPG} would have a * path of {@code DCIM/Vacation/}." />
      <item value="refresh" />
      <item value="When true, the dialog will wrap the content width." />
      <item value="板" />
      <item value="broad" />
      <item value="borad" />
      <item value="Open a data stream for reading a raw resource. This can only be used * with resources whose value is the name of an asset files -- that is, it can be * used to open drawable, sound, and raw resources; it will fail on string * and color resources." />
      <item value="bit" />
      <item value="Instances of the file descriptor class serve as an opaque handle * to the underlying machine-specific structure representing an open * file, an open socket, or another source or sink of bytes. The * main practical use for a file descriptor is to create a * &lt;code&gt;FileInputStream&lt;/code&gt; or &lt;code&gt;FileOutputStream&lt;/code&gt; to * contain it." />
      <item value="capacity" />
      <item value="Relative &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;. * * &lt;p&gt; Writes the given byte into this buffer at the current * position, and then increments the position. &lt;/p&gt;" />
      <item value="Allocates a new byte buffer. * * &lt;p&gt; The new buffer's position will be zero, its limit will be its * capacity, its mark will be undefined, and each of its elements will be * initialized to zero. It will have a {@link #array backing array}, * and its {@link #arrayOffset array offset} will be zero." />
      <item value="Allocates a new direct byte buffer. * * &lt;p&gt; The new buffer's position will be zero, its limit will be its * capacity, its mark will be undefined, and each of its elements will be * initialized to zero. Whether or not it has a * {@link #hasArray backing array} is unspecified." />
      <item value="model" />
      <item value="Filtering affects the sampling of bitmaps when they are transformed. * Filtering does not affect how the colors in the bitmap are converted into * device pixels." />
      <item value="Helper for setFlags(), setting or clearing the FILTER_BITMAP_FLAG bit. * Filtering affects the sampling of bitmaps when they are transformed. * Filtering does not affect how the colors in the bitmap are converted into * device pixels. That is dependent on dithering and xfermodes." />
      <item value="Paint flag that enables bilinear sampling on scaled bitmaps. * * &lt;p&gt;If cleared, scaled bitmaps will be drawn with nearest neighbor * sampling, likely resulting in artifacts. This should generally be on * when drawing bitmaps, unless performance-bound (rendering to software * canvas) or preferring pixelation artifacts to blurriness when scaling * significantly.&lt;/p&gt; * * &lt;p&gt;If bitmaps are scaled for device density at creation time (as * resource bitmaps often are) the filtering will already have been * done.&lt;/p&gt;" />
      <item value="The paint used to compose the layer. This argument is optional * and can be null. It is ignored when the layer type is * {@link #LAYER_TYPE_NONE}" />
      <item value="固件版本号" />
      <item value="型号" />
      <item value="An object that may hold resources (such as file or socket handles) * until it is closed. The {@link #close()} method of an {@code AutoCloseable} * object is called automatically when exiting a {@code * try}-with-resources block for which the object has been declared in * the resource specification header. This construction ensures prompt * release, avoiding resource exhaustion exceptions and errors that * may otherwise occur." />
      <item value="Tries to resume this continuation with a given value and returns non-null object token if it was successful, * or `null` otherwise (it was already resumed or cancelled). When non-null object was returned, * [completeResume] must be invoked with it. * * When [idempotent] is not `null`, this function performs _idempotent_ operation, so that * further invocations with the same non-null reference produce the same result. * * @suppress **This is unstable API and it is subject to change.**" />
      <item value="Tries to resume this continuation with a given value and returns non-null object token if it was successful, * or `null` otherwise (it was already resumed or cancelled). When non-null object was returned, * [completeResume] must be invoked with it." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="99" />
        <entry key="ENGLISH" value="518" />
        <entry key="CHINESE_TRADITIONAL" value="223" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SAMOAN" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
      </youdao-translate>
    </option>
  </component>
</application>