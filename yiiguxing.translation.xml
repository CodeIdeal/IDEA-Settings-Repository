<application>
  <component name="AppStorage">
    <histories>
      <item value="分割线" />
      <item value="水平" />
      <item value="横" />
      <item value="Configure this client to retry or not when a connectivity problem is encountered. By default, * this client silently recovers from the following problems: * &lt;ul&gt; * &lt;li&gt;&lt;strong&gt;Unreachable IP addresses.&lt;/strong&gt; If the URL's host has multiple IP addresses, * failure to reach any individual IP address doesn't fail the overall request. This can * increase availability of multi-homed services. * &lt;li&gt;&lt;strong&gt;Stale pooled connections.&lt;/strong&gt; The {@link ConnectionPool} reuses sockets * to decrease request latency, but these connections will occasionally time out. * &lt;li&gt;&lt;strong&gt;Unreachable proxy servers.&lt;/strong&gt; A {@link ProxySelector} can be used to * attempt multiple proxy servers in sequence, eventually falling back to a direct * connection. * &lt;/ul&gt; * Set this to false to avoid retrying requests when doing so is destructive. In this case the * calling application should do its own recovery of connectivity failures." />
      <item value="on Fail" />
      <item value="The queue used for holding tasks and handing off to worker * threads. We do not require that workQueue.poll() returning * null necessarily means that workQueue.isEmpty(), so rely * solely on isEmpty to see if the queue is empty (which we must * do for example when deciding whether to transition from * SHUTDOWN to TIDYING). This accommodates special-purpose * queues such as DelayQueues for which poll() is allowed to * return null even if it may later return non-null when delays * expire." />
      <item value="超出范围" />
      <item value="logging in…" />
      <item value="abnormal" />
      <item value="unbind" />
      <item value="untied" />
      <item value="is User Valid" />
      <item value="associated" />
      <item value="Called to refresh an action mode's action menu whenever it is invalidated." />
      <item value="complie" />
      <item value="status" />
      <item value="state" />
      <item value="handle" />
      <item value="disclaimer" />
      <item value="Inserts the specified element into this queue if it is possible to do * so immediately without violating capacity restrictions. * When using a capacity-restricted queue, this method is generally * preferable to {@link #add}, which can fail to insert an element only * by throwing an exception." />
      <item value="I agree. The alternative, which I think would be worse, is to post // something and tell the subclasses later. This is bad because there // will be a window where mScrollX/Y is different from what the app // thinks it is." />
      <item value="Code Point" />
      <item value="Determines if the specified character is white space according to Java. * A character is a Java whitespace character if and only if it satisfies * one of the following criteria:" />
      <item value="If set in an Intent passed to {@link Context#startActivity Context.startActivity()}, * this flag will cause a newly launching task to be placed on top of the current * home activity task (if there is one). That is, pressing back from the task * will always return the user to home even if that was not the last activity they * saw. This can only be used in conjunction with {@link #FLAG_ACTIVITY_NEW_TASK}." />
      <item value="By default a document created by {@link #FLAG_ACTIVITY_NEW_DOCUMENT} will * have its entry in recent tasks removed when the user closes it (with back * or however else it may finish()). If you would like to instead allow the * document to be kept in recents so that it can be re-launched, you can use * this flag. When set and the task's activity is finished, the recents * entry will remain in the interface for the user to re-launch it, like a * recents entry for a top-level application." />
      <item value="If set, the broadcast will be visible to receivers in Instant Apps. By default Instant Apps * will not receive broadcasts." />
      <item value="If set, when sending a broadcast the recipient is allowed to run at * foreground priority, with a shorter timeout interval. During normal * broadcasts the receivers are not automatically hoisted out of the * background priority class." />
      <item value="完善" />
      <item value="Allows Room to destructively recreate database tables if {@link Migration}s that would * migrate old database schemas to the latest schema version are not found. * &lt;p&gt; * When the database version on the device does not match the latest schema version, Room * runs necessary {@link Migration}s on the database. * &lt;p&gt; * If it cannot find the set of {@link Migration}s that will bring the database to the * current version, it will throw an {@link IllegalStateException}. * &lt;p&gt; * You can call this method to change this behavior to re-create the database instead of * crashing. * &lt;p&gt; * Note that this will delete all of the data in the database tables managed by Room." />
      <item value="Paper" />
      <item value="major" />
      <item value="Wite" />
      <item value="User valid" />
      <item value="Active" />
      <item value="Requests that the file or directory denoted by this abstract * pathname be deleted when the virtual machine terminates. * Files (or directories) are deleted in the reverse order that * they are registered. Invoking this method to delete a file or * directory that is already registered for deletion has no effect. * Deletion will be attempted only for normal termination of the * virtual machine, as defined by the Java Language Specification. * * &lt;p&gt; Once deletion has been requested, it is not possible to cancel the * request. This method should therefore be used with care. * * &lt;P&gt; * Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as * the resulting protocol cannot be made to work reliably. The * {@link java.nio.channels.FileLock FileLock} * facility should be used instead. * * &lt;p&gt;&lt;i&gt;Note that on Android, the application lifecycle does not include VM termination, * so calling this method will not ensure that files are deleted&lt;/i&gt;. Instead, you should * use the most appropriate out of: * &lt;ul&gt; * &lt;li&gt;Use a {@code finally} clause to manually invoke {@link #delete}. * &lt;li&gt;Maintain your own set of files to delete, and process it at an appropriate point * in your application's lifecycle. * &lt;li&gt;Use the Unix trick of deleting the file as soon as all readers and writers have * opened it. No new readers/writers will be able to access the file, but all existing * ones will still have access until the last one closes the file." />
      <item value="注销" />
      <item value="cancellation" />
      <item value="if it is eligible to be re-used and the pool * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it." />
      <item value="Activity Action: Display the data to the user. This is the most common * action performed on data -- it is the generic action you can use on * a piece of data to get the most reasonable thing to occur. For example, * when used on a contacts entry it will view the entry; when used on a * mailto: URI it will bring up a compose window filled with the information * supplied by the URI; when used with a tel: URI it will invoke the * dialer." />
      <item value="The general type of window. There are three main classes of * window types: * &lt;ul&gt; * &lt;li&gt; &lt;strong&gt;Application windows&lt;/strong&gt; (ranging from * {@link #FIRST_APPLICATION_WINDOW} to * {@link #LAST_APPLICATION_WINDOW}) are normal top-level application * windows. For these types of windows, the {@link #token} must be * set to the token of the activity they are a part of (this will * normally be done for you if {@link #token} is null). * &lt;li&gt; &lt;strong&gt;Sub-windows&lt;/strong&gt; (ranging from * {@link #FIRST_SUB_WINDOW} to * {@link #LAST_SUB_WINDOW}) are associated with another top-level * window. For these types of windows, the {@link #token} must be * the token of the window it is attached to. * &lt;li&gt; &lt;strong&gt;System windows&lt;/strong&gt; (ranging from * {@link #FIRST_SYSTEM_WINDOW} to * {@link #LAST_SYSTEM_WINDOW}) are special types of windows for * use by the system for specific purposes. They should not normally * be used by applications, and a special permission is required * to use them." />
      <item value="resolution Strategy" />
      <item value="the exit value of the subprocess represented by this * {@code Process} object. By convention, the value * {@code 0} indicates normal termination." />
      <item value="Causes the current thread to wait, if necessary, until the * process represented by this {@code Process} object has * terminated. This method returns immediately if the subprocess * has already terminated. If the subprocess has not yet * terminated, the calling thread will be blocked until the * subprocess exits." />
      <item value="Executes the specified string command in a separate process with the * specified environment and working directory. * * &lt;p&gt;This is a convenience method. An invocation of the form * &lt;tt&gt;exec(command, envp, dir)&lt;/tt&gt; * behaves in exactly the same way as the invocation * &lt;tt&gt;{@link #exec(String[], String[], File) exec}(cmdarray, envp, dir)&lt;/tt&gt;, * where &lt;code&gt;cmdarray&lt;/code&gt; is an array of all the tokens in * &lt;code&gt;command&lt;/code&gt;. * * &lt;p&gt;More precisely, the &lt;code&gt;command&lt;/code&gt; string is broken * into tokens using a {@link StringTokenizer} created by the call * &lt;code&gt;new {@link StringTokenizer}(command)&lt;/code&gt; with no * further modification of the character categories. The tokens * produced by the tokenizer are then placed in the new string * array &lt;code&gt;cmdarray&lt;/code&gt;, in the same order." />
      <item value="Busy" />
      <item value="persist" />
      <item value="Choses" />
      <item value="Chose" />
      <item value="Copies an array from the specified source array, beginning at the * specified position, to the specified position of the destination array. * A subsequence of array components are copied from the source * array referenced by &lt;code&gt;src&lt;/code&gt; to the destination array * referenced by &lt;code&gt;dest&lt;/code&gt;. The number of components copied is * equal to the &lt;code&gt;length&lt;/code&gt; argument. The components at * positions &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+length-1&lt;/code&gt; in the source array are copied into * positions &lt;code&gt;destPos&lt;/code&gt; through * &lt;code&gt;destPos+length-1&lt;/code&gt;, respectively, of the destination * array. * &lt;p&gt; * If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the * same array object, then the copying is performed as if the * components at positions &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary * array with &lt;code&gt;length&lt;/code&gt; components and then the contents of * the temporary array were copied into positions * &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the * destination array. * &lt;p&gt; * If &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. * &lt;p&gt; * If &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown and the destination * array is not modified. * &lt;p&gt; * Otherwise, if any of the following is true, an * &lt;code&gt;ArrayStoreException&lt;/code&gt; is thrown and the destination is * not modified: * &lt;ul&gt; * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an object that is not an * array. * &lt;li&gt;The &lt;code&gt;dest&lt;/code&gt; argument refers to an object that is not an * array. * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument and &lt;code&gt;dest&lt;/code&gt; argument refer * to arrays whose component types are different primitive types. * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a primitive * component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array * with a reference component type. * &lt;li&gt;The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a reference * component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array * with a primitive component type. * &lt;/ul&gt; * &lt;p&gt; * Otherwise, if any of the following is true, an * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is * thrown and the destination is not modified: * &lt;ul&gt; * &lt;li&gt;The &lt;code&gt;srcPos&lt;/code&gt; argument is negative. * &lt;li&gt;The &lt;code&gt;destPos&lt;/code&gt; argument is negative. * &lt;li&gt;The &lt;code&gt;length&lt;/code&gt; argument is negative. * &lt;li&gt;&lt;code&gt;srcPos+length&lt;/code&gt; is greater than * &lt;code&gt;src.length&lt;/code&gt;, the length of the source array. * &lt;li&gt;&lt;code&gt;destPos+length&lt;/code&gt; is greater than * &lt;code&gt;dest.length&lt;/code&gt;, the length of the destination array. * &lt;/ul&gt; * &lt;p&gt; * Otherwise, if any actual component of the source array from * position &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+length-1&lt;/code&gt; cannot be converted to the component * type of the destination array by assignment conversion, an * &lt;code&gt;ArrayStoreException&lt;/code&gt; is thrown. In this case, let * &lt;b&gt;&lt;i&gt;k&lt;/i&gt;&lt;/b&gt; be the smallest nonnegative integer less than * length such that &lt;code&gt;src[srcPos+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; * cannot be converted to the component type of the destination * array; when the exception is thrown, source array components from * positions &lt;code&gt;srcPos&lt;/code&gt; through * &lt;code&gt;srcPos+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1&lt;/code&gt; * will already have been copied to destination array positions * &lt;code&gt;destPos&lt;/code&gt; through * &lt;code&gt;destPos+&lt;/code&gt;&lt;i&gt;k&lt;/I&gt;&lt;code&gt;-1&lt;/code&gt; and no other * positions of the destination array will have been modified. * (Because of the restrictions already itemized, this * paragraph effectively applies only to the situation where both * arrays have component types that are reference types.)" />
      <item value="Adds all of the elements in the specified collection to this collection * (optional operation). The behavior of this operation is undefined if * the specified collection is modified while the operation is in progress. * (This implies that the behavior of this call is undefined if the * specified collection is this collection, and this collection is * nonempty.)" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="89" />
        <entry key="ENGLISH" value="376" />
        <entry key="CHINESE_TRADITIONAL" value="71" />
        <entry key="ALBANIAN" value="1" />
        <entry key="FRENCH" value="4" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>