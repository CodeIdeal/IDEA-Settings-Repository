<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="931" />
    <option name="newTranslationDialogY" value="415" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="drainage" />
      <item value="muted" />
      <item value="The number of digits allowed in the fraction portion of value." />
      <item value="blur" />
      <item value="area" />
      <item value="stagger" />
      <item value="has Last" />
      <item value="conflated" />
      <item value="Marks declarations that are still experimental in coroutines API, which means that the design of the corresponding declarations has open issues which may (or may not) lead to their changes in the future. Roughly speaking, there is a chance that those declarations will be deprecated in the near future or the semantics of their behavior may change in some way that may break some code." />
      <item value="oprate" />
      <item value="FOLLOW" />
      <item value="banned" />
      <item value="banded" />
      <item value="直播" />
      <item value="直播房间" />
      <item value="直播间" />
      <item value="Living Room" />
      <item value="Live Room" />
      <item value="_supervisor_" />
      <item value="Creates a [CoroutineScope] and calls the specified suspend block with this scope. The provided scope inherits its [coroutineContext][CoroutineScope.coroutineContext] from the outer scope, but overrides the context's [Job]." />
      <item value="Dynamically modify the server environment according to the compilation parameters" />
      <item value="Unintercepted" />
      <item value="The prompt cancellation guarantee is the result of a coordinated implementation inside `suspendCancellableCoroutine` function and the [CoroutineDispatcher] class. The coroutine dispatcher checks for the status of the [Job] immediately before continuing its normal execution and aborts this normal execution, calling all the corresponding cancellation handlers, if the job was cancelled. If a custom implementation of [ContinuationInterceptor] is used in a coroutine's context that does not extend [CoroutineDispatcher] class, then there is no prompt cancellation guarantee. A custom continuation interceptor can resume execution of a previously suspended coroutine even if its job was already cancelled." />
      <item value="Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine. In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an [" />
      <item value="For USAGE_IO_OUTPUT, destroy() implies setSurface(null)." />
      <item value="Frees any native resources associated with this object. The primary use is to force immediate cleanup of resources when it is believed the GC will not respond quickly enough." />
      <item value="EXTENSION" />
      <item value="eturns the smallest (closest to negative infinity) {@code double} value that is greater than or equal to the argument and is equal to a mathematical integer. Special cases: &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical integer, then the result is the same as the argument. &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument. &lt;li&gt;If the argument value is less than zero but greater than -1.0, then the result is negative zero.&lt;ul&gt; Note that the value of {@code Math.ceil(x)} is exactly the value of {@code -Math.floor(-x)}." />
      <item value="BULLETIN" />
      <item value="Creates the directory named by this abstract pathname." />
      <item value="Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary parent directories." />
      <item value="extras" />
      <item value="extrs" />
      <item value="admins" />
      <item value="padding Hor" />
      <item value="Continuous" />
      <item value="Constant for {@link getActionMasked}: A non-primary pointer has gone down. &lt;p&gt; Use {@link getActionIndex} to retrieve the index of the pointer that changed. &lt;p&gt;&lt;p&gt; The index is encoded in the {@link ACTION_POINTER_INDEX_MASK} bits of the unmasked action returned by {@link getAction}. &lt;p&gt;" />
      <item value="Call this when your activity is done and should be closed. The ActivityResult is propagated back to whoever launched you via onActivityResult()." />
      <item value="Previous position of the first item that was removed" />
      <item value="Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive). The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. Structural changes in the base list make the behavior of the view undefined." />
      <item value="compatible getLoadMoreViewCount and getEmptyViewCount may change" />
      <item value="since onChanged() is implemented by the app, it could do anything, including removing itself from {@link mObservers} - and that could cause problems if an iterator is used on the ArrayList {@link mObservers}. to avoid such problems, just march thru the list in the reverse order." />
      <item value="Notify any registered observers that the data set has changed. &lt;p&gt;There are two different classes of data change events, item changes and structural changes. Item changes are when a single item has its data updated but no positional changes have occurred. Structural changes are when items are inserted, removed or moved within the data set.&lt;p&gt; &lt;p&gt;This event does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. LayoutManagers will be forced to fully rebind and relayout all visible views.&lt;p&gt; &lt;p&gt;&lt;code&gt;RecyclerView&lt;code&gt; will attempt to synthesize visible structural change events for adapters that report that they have {@link hasStableIds() stable IDs} when this method is used. This can help for the purposes of animation and visual object persistence but individual item views will still need to be rebound and relaid out.&lt;p&gt; &lt;p&gt;If you are writing an adapter it will always be more efficient to use the more specific change events if you can. Rely on &lt;code&gt;notifyDataSetChanged()&lt;code&gt; as a last resort.&lt;p&gt;" />
      <item value="calculate Time For Deceleration" />
      <item value="Deceleration" />
      <item value="Detector" />
      <item value="Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine. In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException]." />
      <item value="Opens subscription to this [BroadcastChannel] and makes sure that the given [block] consumes all elements from it by always invoking [cancel][ReceiveChannel.cancel] after the execution of the block. Note: This API will become obsolete in future updates with introduction of lazy asynchronous streams. See [issue 254](https:github.comKotlinkotlinx.coroutinesissues254)." />
      <item value="Cancels reception of remaining elements from this channel with an optional [cause]. This function closes the channel and removes all buffered sent elements from it. A cause can be used to specify an error message or to provide other details on the cancellation reason for debugging purposes. If the cause is not specified, then an instance of [CancellationException] with a default message is created to [close][SendChannel.close] the channel. Immediately after invocation of this function [isClosedForReceive] and [isClosedForSend][SendChannel.isClosedForSend] on the side of [SendChannel] start returning `true`. Any attempt to send to or receive from this channel will lead to a [CancellationException]." />
      <item value="关注Channel" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="107" />
        <entry key="ENGLISH" value="676" />
        <entry key="CHINESE_TRADITIONAL" value="386" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="CROATIAN" value="2" />
        <entry key="LATIN" value="1" />
        <entry key="SAMOAN" value="1" />
        <entry key="UZBEK" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1615191475111" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
      </youdao-translate>
    </option>
  </component>
</application>