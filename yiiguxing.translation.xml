<application>
  <component name="AppStorage">
    <histories>
      <item value="Coordinator" />
      <item value="Encodes" />
      <item value="Get the maximum supported Transmit packet size for the underlying transport. * Use this to optimize the writes done to the output socket, to avoid sending * half full packets." />
      <item value="Get the maximum supported Receive packet size for the underlying transport. * Use this to optimize the reads done on the input stream, as any call to read * will return a maximum of this amount of bytes - or for some transports a * multiple of this value." />
      <item value="Operate" />
      <item value="Operatation" />
      <item value="A linear collection that supports element insertion and removal at * both ends. The name &lt;i&gt;deque&lt;/i&gt; is short for &quot;double ended queue&quot; * and is usually pronounced &quot;deck&quot;. Most {@code Deque} * implementations place no fixed limits on the number of elements * they may contain, but this interface supports capacity-restricted * deques as well as those with no fixed size limit." />
      <item value="Retrieves and removes the head of this queue, waiting if necessary * until an element with an expired delay is available on this queue." />
      <item value="A mix-in style interface for marking objects that should be * acted upon after a given delay." />
      <item value="An unbounded {@linkplain BlockingQueue blocking queue} of * {@code Delayed} elements, in which an element can only be taken * when its delay has expired. The &lt;em&gt;head&lt;/em&gt; of the queue is that * {@code Delayed} element whose delay expired furthest in the * past. If no delay has expired there is no head and {@code poll} * will return {@code null}. Expiration occurs when an element's * {@code getDelay(TimeUnit.NANOSECONDS)} method returns a value less * than or equal to zero. Even though unexpired elements cannot be * removed using {@code take} or {@code poll}, they are otherwise * treated as normal elements. For example, the {@code size} method * returns the count of both expired and unexpired elements. * This queue does not permit null elements." />
      <item value="Returns the minimum number of bytes that can be used to store this bitmap's pixels." />
      <item value="Returns the size of the allocated memory used to store this bitmap's pixels." />
      <item value="Signals the event of this or the other SingleSource whichever signals first." />
      <item value="Allocation" />
      <item value="establish" />
      <item value="Discovery" />
      <item value="State" />
      <item value="Statu" />
      <item value=" Composite" />
      <item value="申请权限" />
      <item value="Criteria for filtering result from Bluetooth LE scans. A {@link ScanFilter} allows clients to * restrict scan results to only those that are of interest to them." />
      <item value="Android 7.0 (API 24) introduces an undocumented scan throttle for applications that try to scan more than 5 times during * a 30 second window. More on the topic: https://blog.classycode.com/undocumented-android-7-ble-behavior-changes-d1a9bd87d983" />
      <item value="For sticky mode, higher threshold of signal strength and sightings is required * before reporting by hw" />
      <item value="In Aggressive mode, hw will determine a match sooner even with feeble signal strength * and few number of sightings/match in a duration." />
      <item value="Trigger a callback for every Bluetooth advertisement found that matches the filter criteria. * If no filter is active, all advertisement packets are reported." />
      <item value="Receive a callback when advertisements are no longer received from a device that has been * previously reported by a first match callback." />
      <item value="A result callback is only triggered for the first advertisement packet received that matches * the filter criteria." />
      <item value="Scan using highest duty cycle. It's recommended to only use this mode when the application is * running in the foreground." />
      <item value="LATENCY" />
      <item value="OPPORTUNISTIC" />
      <item value="Asynchronously subscribes Observers to this ObservableSource on the specified {@link Scheduler}." />
      <item value="Maual" />
      <item value="audio Info" />
      <item value="signt" />
      <item value="ATTRACTION" />
      <item value="APP VERSION CODE" />
      <item value="APP VERSION NAME" />
      <item value="Flavor" />
      <item value="Contrl" />
      <item value="ALBUM" />
      <item value="intercept" />
      <item value="Album" />
      <item value="Aulbum" />
      <item value="model" />
      <item value="radio" />
      <item value="unknown" />
      <item value="unknow" />
      <item value="coustom" />
      <item value="Punch" />
      <item value="Used to identify the creator of this token, for example the class name. * Instead of creating multiple tokens with the same descriptor, consider adding a suffix to * help identify them." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="96" />
        <entry key="ENGLISH" value="443" />
        <entry key="CHINESE_TRADITIONAL" value="139" />
        <entry key="ALBANIAN" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SAMOAN" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
      </youdao-translate>
    </option>
  </component>
</application>