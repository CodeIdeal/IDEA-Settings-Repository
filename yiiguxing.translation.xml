<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="931" />
    <option name="newTranslationDialogY" value="415" />
    <histories>
      <item value="Starts coroutine related to this job (if any) if it was not started yet. The result `true` if this invocation actually started coroutine or `false` if it was already started or completed." />
      <item value="an optional function that is called when element was sent but was not delivered to the consumer. See &quot;Undelivered elements&quot; section in [Channel] documentation." />
      <item value="Requests a rendezvous channel in the `Channel(...)` factory function &amp;mdash; a channel that does not have a buffer." />
      <item value="Requests a conflated channel in the `Channel(...)` factory function. This is a shortcut to creating a channel with [`onBufferOverflow = DROP_OLDEST`][BufferOverflow.DROP_OLDEST]." />
      <item value="&lt;p&gt;Contains useful information about the current RecyclerView state like target scroll position or view focus. State object can also keep arbitrary data, identified by resource ids.&lt;p&gt; &lt;p&gt;Often times, RecyclerView components will need to pass information between each other. To provide a well defined data bus between components, RecyclerView passes the same State object to component callbacks and these components can use it to exchange data.&lt;p&gt; &lt;p&gt;If you implement custom components, you can use State's putgetremove methods to pass data between your components without needing to manage their lifecycles.&lt;p&gt;" />
      <item value="module" />
      <item value="contract" />
      <item value="Flag for {@link showSoftInput} to indicate that the user has forced the input method open (such as by long-pressing menu) so it should not be closed until they explicitly do so." />
      <item value="Flag for {@link showSoftInput} to indicate that this is an implicit request to show the input window, not as the result of a direct request by the user. The window may not be shown in this case." />
      <item value="Provides additional operating flags. Currently may be 0 or have the {@link SHOW_IMPLICIT} bit set." />
      <item value="he system window inset represents the area of a full-screen window that is partially or fully obscured by the status bar, navigation bar, IME or other system windows." />
      <item value="silver" />
      <item value="sliver" />
      <item value="copper" />
      <item value="board" />
      <item value="borard" />
      <item value="leaderborard" />
      <item value="Called when the activity has detected the user's press of the back key. The {@link getOnBackPressedDispatcher() OnBackPressedDispatcher} will be given a chance to handle the back button before the default behavior of {@link android.app.ActivityonBackPressed()} is invoked." />
      <item value="效果" />
      <item value="Inset" />
      <item value="Height as measured during measure pass." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}. Adding an adapter without stable ids will result in an" />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless and item is moved between {@link Adapter}s. Adding an adapter without stable ids will result in an" />
      <item value="Postponed" />
      <item value="Position of ViewHolder to be returned." />
      <item value="Returns the total number of items that can be laid out. Note that this number is not necessarily equal to the number of items in the adapter, so you should always use this number for your position calculations and never access the adapter directly." />
      <item value="The classes that affect character-level text formatting extend this class. Most extend its subclass {@link MetricAffectingSpan}, but simple ones may just implement {@link UpdateAppearance}." />
      <item value="Bitmask of bits that are relevent for controlling pointmark behavior of spans. MARK and POINT are conceptually located &lt;i&gt;between&lt;i&gt; two adjacent characters. A MARK is &quot;attached&quot; to the character before, while a POINT will stick to the character after. The insertion cursor is conceptually located between the MARK and the POINT. As a result, inserting a new character between a MARK and a POINT will leave the MARK unchanged, while the POINT will be shifted, now located after the inserted character and still glued to the same character after it. Depending on whether the insertion happens at the beginning or the end of a span, the span will hence be expanded to &lt;i&gt;include&lt;i&gt; the new character (when the span is using a MARK at its beginning or a POINT at its end) or it will be &lt;i&gt;excluded&lt;i&gt;. Note that &lt;i&gt;before&lt;i&gt; and &lt;i&gt;after&lt;i&gt; here refer to offsets in the String, which are independent from the visual representation of the text (left-to-right or right-to-left)." />
      <item value="Whether to add the given target to the list of targets to exclude from this transition. The &lt;code&gt;exclude&lt;code&gt; parameter specifies whether the target should be added to or removed from the excluded list. &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on a view hierarchy while skipping target views that should not be part of the transition. For example, you may want to avoid animating children of a specific ListView or Spinner. Views can be excluded either by their id, or by their instance reference, or by the Class of that view (eg, {@link Spinner}).&lt;p&gt; @param target The target to ignore when running this transition. @param exclude Whether to add the target to or remove the target from the current list of excluded targets." />
      <item value="distinct Until Changed" />
      <item value="Tell the host application the current progress of loading a page. @param view The WebView that initiated the callback. @param newProgress Current page loading progress, represented by an integer between 0 and 100." />
      <item value="ContentLoadingProgressBar implements a ProgressBar that waits a minimum time to be dismissed before showing. Once visible, the progress bar will be visible for a minimum amount of time to avoid &quot;flashes&quot; in the UI when an event could take a largely variable time to complete (from none, to a user perceivable amount)" />
      <item value="Called when a view created by this adapter has been attached to a window. &lt;p&gt;This can be used as a reasonable signal that the view is about to be seen by the user. If the adapter previously freed any resources in {@link onViewDetachedFromWindow(RecyclerView.ViewHolder) onViewDetachedFromWindow} those resources should be restored here.&lt;p&gt;" />
      <item value="Idle" />
      <item value="Returns The itemId represented by this ViewHolder. @return The item's id if adapter has stable ids, {@link RecyclerViewNO_ID} otherwise" />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless an item is moved between {@link Adapter}s." />
      <item value="Setting this to {@code false} will allow nested adapters to share {@link ViewHolder}s but it also means these adapters should not have conflicting view types ({@link AdaptergetItemViewType(int)}) such that two different adapters return the same view type for different {@link ViewHolder}s." />
      <item value="assumes all assigned adapters share a global view type pool such that they use the same view types to refer to the same {@link ViewHolder}s." />
      <item value="If {@code false}, {@link ConcatAdapter} assumes all assigned adapters share a global view type pool such that they use the same view types to refer to the same {@link ViewHolder}s. &lt;p&gt; Setting this to {@code false} will allow nested adapters to share {@link ViewHolder}s but it also means these adapters should not have conflicting view types ({@link AdaptergetItemViewType(int)}) such that two different adapters return the same view type for different {@link ViewHolder}s. By default, it is set to {@code true} which means {@link ConcatAdapter} will isolate view types across adapters, preventing them from using the same {@link ViewHolder}s." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless and item is moved between {@link Adapter}s. Adding an adapter without stable ids will result in an {@link IllegalArgumentException}." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}. Adding an adapter without stable ids will result in an {@link IllegalArgumentException}." />
      <item value="Called by RecyclerView when it starts observing this Adapter. &lt;p&gt; Keep in mind that same adapter may be observed by multiple RecyclerViews. @param recyclerView The RecyclerView instance which started observing this adapter. @see onDetachedFromRecyclerView(RecyclerView)" />
      <item value="Wraper" />
      <item value="Wrap" />
      <item value="args after sale status" />
      <item value="Write Transport Activity" />
      <item value="Indicates whether each item in the data set can be represented with a unique identifier of type {@link java.lang.Long}." />
      <item value="Any usage of a declaration annotated with `@ExperimentalContracts` must be accepted either by annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalContracts::class)`, or by using the compiler argument `-Xopt-in=kotlin.contracts.ExperimentalContracts`." />
      <item value="Contracts" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="103" />
        <entry key="ENGLISH" value="627" />
        <entry key="CHINESE_TRADITIONAL" value="336" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SAMOAN" value="1" />
        <entry key="UZBEK" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1610344451100" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
      </youdao-translate>
    </option>
  </component>
</application>