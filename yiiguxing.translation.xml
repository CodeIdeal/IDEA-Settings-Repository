<application>
  <component name="AppStorage">
    <histories>
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}. Adding an adapter without stable ids will result in an" />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless and item is moved between {@link Adapter}s. Adding an adapter without stable ids will result in an" />
      <item value="Postponed" />
      <item value="Position of ViewHolder to be returned." />
      <item value="Returns the total number of items that can be laid out. Note that this number is not necessarily equal to the number of items in the adapter, so you should always use this number for your position calculations and never access the adapter directly." />
      <item value="The classes that affect character-level text formatting extend this class. Most extend its subclass {@link MetricAffectingSpan}, but simple ones may just implement {@link UpdateAppearance}." />
      <item value="Bitmask of bits that are relevent for controlling pointmark behavior of spans. MARK and POINT are conceptually located &lt;i&gt;between&lt;i&gt; two adjacent characters. A MARK is &quot;attached&quot; to the character before, while a POINT will stick to the character after. The insertion cursor is conceptually located between the MARK and the POINT. As a result, inserting a new character between a MARK and a POINT will leave the MARK unchanged, while the POINT will be shifted, now located after the inserted character and still glued to the same character after it. Depending on whether the insertion happens at the beginning or the end of a span, the span will hence be expanded to &lt;i&gt;include&lt;i&gt; the new character (when the span is using a MARK at its beginning or a POINT at its end) or it will be &lt;i&gt;excluded&lt;i&gt;. Note that &lt;i&gt;before&lt;i&gt; and &lt;i&gt;after&lt;i&gt; here refer to offsets in the String, which are independent from the visual representation of the text (left-to-right or right-to-left)." />
      <item value="Whether to add the given target to the list of targets to exclude from this transition. The &lt;code&gt;exclude&lt;code&gt; parameter specifies whether the target should be added to or removed from the excluded list. &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on a view hierarchy while skipping target views that should not be part of the transition. For example, you may want to avoid animating children of a specific ListView or Spinner. Views can be excluded either by their id, or by their instance reference, or by the Class of that view (eg, {@link Spinner}).&lt;p&gt; @param target The target to ignore when running this transition. @param exclude Whether to add the target to or remove the target from the current list of excluded targets." />
      <item value="distinct Until Changed" />
      <item value="Tell the host application the current progress of loading a page. @param view The WebView that initiated the callback. @param newProgress Current page loading progress, represented by an integer between 0 and 100." />
      <item value="ContentLoadingProgressBar implements a ProgressBar that waits a minimum time to be dismissed before showing. Once visible, the progress bar will be visible for a minimum amount of time to avoid &quot;flashes&quot; in the UI when an event could take a largely variable time to complete (from none, to a user perceivable amount)" />
      <item value="Called when a view created by this adapter has been attached to a window. &lt;p&gt;This can be used as a reasonable signal that the view is about to be seen by the user. If the adapter previously freed any resources in {@link onViewDetachedFromWindow(RecyclerView.ViewHolder) onViewDetachedFromWindow} those resources should be restored here.&lt;p&gt;" />
      <item value="Idle" />
      <item value="Returns The itemId represented by this ViewHolder. @return The item's id if adapter has stable ids, {@link RecyclerViewNO_ID} otherwise" />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless an item is moved between {@link Adapter}s." />
      <item value="Setting this to {@code false} will allow nested adapters to share {@link ViewHolder}s but it also means these adapters should not have conflicting view types ({@link AdaptergetItemViewType(int)}) such that two different adapters return the same view type for different {@link ViewHolder}s." />
      <item value="assumes all assigned adapters share a global view type pool such that they use the same view types to refer to the same {@link ViewHolder}s." />
      <item value="If {@code false}, {@link ConcatAdapter} assumes all assigned adapters share a global view type pool such that they use the same view types to refer to the same {@link ViewHolder}s. &lt;p&gt; Setting this to {@code false} will allow nested adapters to share {@link ViewHolder}s but it also means these adapters should not have conflicting view types ({@link AdaptergetItemViewType(int)}) such that two different adapters return the same view type for different {@link ViewHolder}s. By default, it is set to {@code true} which means {@link ConcatAdapter} will isolate view types across adapters, preventing them from using the same {@link ViewHolder}s." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless and item is moved between {@link Adapter}s. Adding an adapter without stable ids will result in an {@link IllegalArgumentException}." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}. Adding an adapter without stable ids will result in an {@link IllegalArgumentException}." />
      <item value="Called by RecyclerView when it starts observing this Adapter. &lt;p&gt; Keep in mind that same adapter may be observed by multiple RecyclerViews. @param recyclerView The RecyclerView instance which started observing this adapter. @see onDetachedFromRecyclerView(RecyclerView)" />
      <item value="Wraper" />
      <item value="Wrap" />
      <item value="args after sale status" />
      <item value="Write Transport Activity" />
      <item value="Indicates whether each item in the data set can be represented with a unique identifier of type {@link java.lang.Long}." />
      <item value="Any usage of a declaration annotated with `@ExperimentalContracts` must be accepted either by annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalContracts::class)`, or by using the compiler argument `-Xopt-in=kotlin.contracts.ExperimentalContracts`." />
      <item value="Contracts" />
      <item value="This marker distinguishes the experimental contract declaration API and is used to opt-in for that feature when declaring contracts of user functions. Any usage of a declaration annotated with `@ExperimentalContracts` must be accepted either by annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalContracts::class)`, or by using the compiler argument `-Xopt-in=kotlin.contracts.ExperimentalContracts`." />
      <item value="warp" />
      <item value="特定" />
      <item value="Callers should switch to checking {@link NetworkCapabilitieshasTransport} instead with one of the NetworkCapabilitiesTRANSPORT_ constants : {@link getType} and {@link getTypeName} cannot account for networks using multiple transports. Note that generally apps should not care about transport; {@link NetworkCapabilitiesNET_CAPABILITY_NOT_METERED} and {@link NetworkCapabilitiesgetLinkDownstreamBandwidthKbps} are calls that apps concerned with meteredness or bandwidth should be looking at, as they offer this information with much better accuracy." />
      <item value="add animate to loading dialog" />
      <item value="translaste" />
      <item value="Geometry" />
      <item value="Geogetry" />
      <item value="Geobetry" />
      <item value="gl Viewport" />
      <item value="组件" />
      <item value="Consolidated" />
      <item value="fail" />
      <item value="remove shop name in order detail" />
      <item value="allowobfuscation" />
      <item value="If the superclass is a parameterized type, the {@code Type} * object returned must accurately reflect the actual type * parameters used in the source code. The parameterized type * representing the superclass is created if it had not been * created before. See the declaration of {@link * java.lang.reflect.ParameterizedType ParameterizedType} for the * semantics of the creation process for parameterized types. If * this {@code Class} represents either the {@code Object} * class, an interface, a primitive type, or void, then null is * returned. If this object represents an array class then the * {@code Class} object representing the {@code Object} class is * returned." />
      <item value="Returns the {@code Type} representing the direct superclass of * the entity (class, interface, primitive type or void) represented by * this {@code Class}." />
      <item value="Returns the canonical name of the underlying class as * defined by the Java Language Specification. Returns null if * the underlying class does not have a canonical name (i.e., if * it is a local or anonymous class or an array whose component * type does not have a canonical name). * @return the canonical name of the underlying class if it exists, and * {@code null} otherwise." />
      <item value="precision" />
      <item value="vertex" />
      <item value="Vertices" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="103" />
        <entry key="ENGLISH" value="608" />
        <entry key="CHINESE_TRADITIONAL" value="316" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SAMOAN" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1609751593522" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
      </youdao-translate>
    </option>
  </component>
</application>