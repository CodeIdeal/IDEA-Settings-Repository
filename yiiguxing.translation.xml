<application>
  <component name="AppStorage">
    <histories>
      <item value="Returns The itemId represented by this ViewHolder. @return The item's id if adapter has stable ids, {@link RecyclerViewNO_ID} otherwise" />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless an item is moved between {@link Adapter}s." />
      <item value="Setting this to {@code false} will allow nested adapters to share {@link ViewHolder}s but it also means these adapters should not have conflicting view types ({@link AdaptergetItemViewType(int)}) such that two different adapters return the same view type for different {@link ViewHolder}s." />
      <item value="assumes all assigned adapters share a global view type pool such that they use the same view types to refer to the same {@link ViewHolder}s." />
      <item value="If {@code false}, {@link ConcatAdapter} assumes all assigned adapters share a global view type pool such that they use the same view types to refer to the same {@link ViewHolder}s. &lt;p&gt; Setting this to {@code false} will allow nested adapters to share {@link ViewHolder}s but it also means these adapters should not have conflicting view types ({@link AdaptergetItemViewType(int)}) such that two different adapters return the same view type for different {@link ViewHolder}s. By default, it is set to {@code true} which means {@link ConcatAdapter} will isolate view types across adapters, preventing them from using the same {@link ViewHolder}s." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. Unlike {@link StableIdModeISOLATED_STABLE_IDS}, {@link ConcatAdapter} will not override the returned item ids. In this mode, child {@link Adapter}s must be aware of each-other and never return the same id unless and item is moved between {@link Adapter}s. Adding an adapter without stable ids will result in an {@link IllegalArgumentException}." />
      <item value="In this mode, {@link ConcatAdapter} will return {@code true} from {@link ConcatAdapterhasStableIds()} and will &lt;b&gt;require&lt;b&gt; all added {@link Adapter}s to have stable ids. As two different adapters may return same stable ids because they are unaware of each-other, {@link ConcatAdapter} will isolate each {@link Adapter}'s id pool from each other such that it will overwrite the reported stable id before reporting back to the {@link RecyclerView}. In this mode, the value returned from {@link ViewHoldergetItemId()} might differ from the value returned from {@link AdaptergetItemId(int)}. Adding an adapter without stable ids will result in an {@link IllegalArgumentException}." />
      <item value="Called by RecyclerView when it starts observing this Adapter. &lt;p&gt; Keep in mind that same adapter may be observed by multiple RecyclerViews. @param recyclerView The RecyclerView instance which started observing this adapter. @see onDetachedFromRecyclerView(RecyclerView)" />
      <item value="Wraper" />
      <item value="Wrap" />
      <item value="args after sale status" />
      <item value="Write Transport Activity" />
      <item value="Indicates whether each item in the data set can be represented with a unique identifier of type {@link java.lang.Long}." />
      <item value="Any usage of a declaration annotated with `@ExperimentalContracts` must be accepted either by annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalContracts::class)`, or by using the compiler argument `-Xopt-in=kotlin.contracts.ExperimentalContracts`." />
      <item value="Contracts" />
      <item value="This marker distinguishes the experimental contract declaration API and is used to opt-in for that feature when declaring contracts of user functions. Any usage of a declaration annotated with `@ExperimentalContracts` must be accepted either by annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalContracts::class)`, or by using the compiler argument `-Xopt-in=kotlin.contracts.ExperimentalContracts`." />
      <item value="warp" />
      <item value="特定" />
      <item value="Callers should switch to checking {@link NetworkCapabilitieshasTransport} instead with one of the NetworkCapabilitiesTRANSPORT_ constants : {@link getType} and {@link getTypeName} cannot account for networks using multiple transports. Note that generally apps should not care about transport; {@link NetworkCapabilitiesNET_CAPABILITY_NOT_METERED} and {@link NetworkCapabilitiesgetLinkDownstreamBandwidthKbps} are calls that apps concerned with meteredness or bandwidth should be looking at, as they offer this information with much better accuracy." />
      <item value="add animate to loading dialog" />
      <item value="translaste" />
      <item value="Geometry" />
      <item value="Geogetry" />
      <item value="Geobetry" />
      <item value="gl Viewport" />
      <item value="组件" />
      <item value="Consolidated" />
      <item value="fail" />
      <item value="remove shop name in order detail" />
      <item value="allowobfuscation" />
      <item value="If the superclass is a parameterized type, the {@code Type} * object returned must accurately reflect the actual type * parameters used in the source code. The parameterized type * representing the superclass is created if it had not been * created before. See the declaration of {@link * java.lang.reflect.ParameterizedType ParameterizedType} for the * semantics of the creation process for parameterized types. If * this {@code Class} represents either the {@code Object} * class, an interface, a primitive type, or void, then null is * returned. If this object represents an array class then the * {@code Class} object representing the {@code Object} class is * returned." />
      <item value="Returns the {@code Type} representing the direct superclass of * the entity (class, interface, primitive type or void) represented by * this {@code Class}." />
      <item value="Returns the canonical name of the underlying class as * defined by the Java Language Specification. Returns null if * the underlying class does not have a canonical name (i.e., if * it is a local or anonymous class or an array whose component * type does not have a canonical name). * @return the canonical name of the underlying class if it exists, and * {@code null} otherwise." />
      <item value="precision" />
      <item value="vertex" />
      <item value="Vertices" />
      <item value="If set, and the activity being launched is already running in the * current task, then instead of launching a new instance of that activity, * all of the other activities on top of it will be closed and this Intent * will be delivered to the (now on top) old activity as a new Intent." />
      <item value="Removes the mapping for the specified key from this map if present." />
      <item value="total price to two decimal places" />
      <item value="Triangle" />
      <item value="The renderer only renders * when the surface is created, or when {@link #requestRender} is called." />
      <item value="The renderer is called * continuously to re-render the scene." />
      <item value="处理中" />
      <item value="没有考虑到头布局" />
      <item value="考虑头布局" />
      <item value="add contact server groupId choosing logic" />
      <item value="choosing" />
      <item value="add contact server groupId choose logic" />
      <item value="receive" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="103" />
        <entry key="ENGLISH" value="595" />
        <entry key="CHINESE_TRADITIONAL" value="303" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SAMOAN" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1609751593522" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
      </youdao-translate>
    </option>
  </component>
</application>