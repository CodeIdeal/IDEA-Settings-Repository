<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="931" />
    <option name="newTranslationDialogY" value="415" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="EXTENSION" />
      <item value="eturns the smallest (closest to negative infinity) {@code double} value that is greater than or equal to the argument and is equal to a mathematical integer. Special cases: &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical integer, then the result is the same as the argument. &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument. &lt;li&gt;If the argument value is less than zero but greater than -1.0, then the result is negative zero.&lt;ul&gt; Note that the value of {@code Math.ceil(x)} is exactly the value of {@code -Math.floor(-x)}." />
      <item value="BULLETIN" />
      <item value="Creates the directory named by this abstract pathname." />
      <item value="Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary parent directories." />
      <item value="extras" />
      <item value="extrs" />
      <item value="admins" />
      <item value="padding Hor" />
      <item value="Continuous" />
      <item value="Constant for {@link getActionMasked}: A non-primary pointer has gone down. &lt;p&gt; Use {@link getActionIndex} to retrieve the index of the pointer that changed. &lt;p&gt;&lt;p&gt; The index is encoded in the {@link ACTION_POINTER_INDEX_MASK} bits of the unmasked action returned by {@link getAction}. &lt;p&gt;" />
      <item value="Call this when your activity is done and should be closed. The ActivityResult is propagated back to whoever launched you via onActivityResult()." />
      <item value="Previous position of the first item that was removed" />
      <item value="Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive). The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. Structural changes in the base list make the behavior of the view undefined." />
      <item value="compatible getLoadMoreViewCount and getEmptyViewCount may change" />
      <item value="since onChanged() is implemented by the app, it could do anything, including removing itself from {@link mObservers} - and that could cause problems if an iterator is used on the ArrayList {@link mObservers}. to avoid such problems, just march thru the list in the reverse order." />
      <item value="Notify any registered observers that the data set has changed. &lt;p&gt;There are two different classes of data change events, item changes and structural changes. Item changes are when a single item has its data updated but no positional changes have occurred. Structural changes are when items are inserted, removed or moved within the data set.&lt;p&gt; &lt;p&gt;This event does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. LayoutManagers will be forced to fully rebind and relayout all visible views.&lt;p&gt; &lt;p&gt;&lt;code&gt;RecyclerView&lt;code&gt; will attempt to synthesize visible structural change events for adapters that report that they have {@link hasStableIds() stable IDs} when this method is used. This can help for the purposes of animation and visual object persistence but individual item views will still need to be rebound and relaid out.&lt;p&gt; &lt;p&gt;If you are writing an adapter it will always be more efficient to use the more specific change events if you can. Rely on &lt;code&gt;notifyDataSetChanged()&lt;code&gt; as a last resort.&lt;p&gt;" />
      <item value="calculate Time For Deceleration" />
      <item value="Deceleration" />
      <item value="Detector" />
      <item value="Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine. In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException]." />
      <item value="Opens subscription to this [BroadcastChannel] and makes sure that the given [block] consumes all elements from it by always invoking [cancel][ReceiveChannel.cancel] after the execution of the block. Note: This API will become obsolete in future updates with introduction of lazy asynchronous streams. See [issue 254](https:github.comKotlinkotlinx.coroutinesissues254)." />
      <item value="Cancels reception of remaining elements from this channel with an optional [cause]. This function closes the channel and removes all buffered sent elements from it. A cause can be used to specify an error message or to provide other details on the cancellation reason for debugging purposes. If the cause is not specified, then an instance of [CancellationException] with a default message is created to [close][SendChannel.close] the channel. Immediately after invocation of this function [isClosedForReceive] and [isClosedForSend][SendChannel.isClosedForSend] on the side of [SendChannel] start returning `true`. Any attempt to send to or receive from this channel will lead to a [CancellationException]." />
      <item value="关注Channel" />
      <item value="关注" />
      <item value="Indicates how many of this container's child subtrees contain transient state" />
      <item value="Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible. &lt;p&gt;A view with transient state cannot be trivially rebound from an external data source, such as an adapter binding item views in a list. This may be because the view is performing an animation, tracking user selection of content, or similar.&lt;p&gt; @return true if the view has transient state" />
      <item value="enter" />
      <item value="enter tip" />
      <item value="The screen density expressed as dots-per-inch. May be either {@link DENSITY_LOW}, {@link DENSITY_MEDIUM}, or {@link DENSITY_HIGH}." />
      <item value="Calculates the scroll speed. &lt;p&gt;By default, LinearSmoothScroller assumes this method always returns the same value and caches the result of calling it. @param displayMetrics DisplayMetrics to be used for real dimension calculations @return The time (in ms) it should take for each pixel. For instance, if returned value is 2 ms, it means scrolling 1000 pixels with LinearInterpolation should take 2 seconds." />
      <item value="Constant for {@link getActionMasked}: A pressed gesture has started, the motion contains the initial starting location. &lt;p&gt; This is also a good time to check the button state to distinguish secondary and tertiary button clicks and handle them appropriately. Use {@link getButtonState} to retrieve the button state." />
      <item value="When LayoutManager needs to scroll to a position, it sets this variable and requests a layout which will check this variable and re-layout accordingly." />
      <item value="May be null. The relative positions [0..1] of each corresponding color in the colors array. If this is null, the the colors are distributed evenly along the gradient line." />
      <item value="Return the stable ID for the item at &lt;code&gt;position&lt;code&gt;. If {@link hasStableIds()} would return false this method should return {@link NO_ID}. The default implementation of this method returns {@link NO_ID}." />
      <item value="Starts coroutine related to this job (if any) if it was not started yet. The result `true` if this invocation actually started coroutine or `false` if it was already started or completed." />
      <item value="an optional function that is called when element was sent but was not delivered to the consumer. See &quot;Undelivered elements&quot; section in [Channel] documentation." />
      <item value="Requests a rendezvous channel in the `Channel(...)` factory function &amp;mdash; a channel that does not have a buffer." />
      <item value="Requests a conflated channel in the `Channel(...)` factory function. This is a shortcut to creating a channel with [`onBufferOverflow = DROP_OLDEST`][BufferOverflow.DROP_OLDEST]." />
      <item value="&lt;p&gt;Contains useful information about the current RecyclerView state like target scroll position or view focus. State object can also keep arbitrary data, identified by resource ids.&lt;p&gt; &lt;p&gt;Often times, RecyclerView components will need to pass information between each other. To provide a well defined data bus between components, RecyclerView passes the same State object to component callbacks and these components can use it to exchange data.&lt;p&gt; &lt;p&gt;If you implement custom components, you can use State's putgetremove methods to pass data between your components without needing to manage their lifecycles.&lt;p&gt;" />
      <item value="module" />
      <item value="contract" />
      <item value="Flag for {@link showSoftInput} to indicate that the user has forced the input method open (such as by long-pressing menu) so it should not be closed until they explicitly do so." />
      <item value="Flag for {@link showSoftInput} to indicate that this is an implicit request to show the input window, not as the result of a direct request by the user. The window may not be shown in this case." />
      <item value="Provides additional operating flags. Currently may be 0 or have the {@link SHOW_IMPLICIT} bit set." />
      <item value="he system window inset represents the area of a full-screen window that is partially or fully obscured by the status bar, navigation bar, IME or other system windows." />
      <item value="silver" />
      <item value="sliver" />
      <item value="copper" />
      <item value="board" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="104" />
        <entry key="ENGLISH" value="656" />
        <entry key="CHINESE_TRADITIONAL" value="365" />
        <entry key="ALBANIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SAMOAN" value="1" />
        <entry key="UZBEK" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1611540127368" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE_TRADITIONAL" />
      </google-translate>
    </option>
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5035e0423bd01874" />
      </youdao-translate>
    </option>
  </component>
</application>